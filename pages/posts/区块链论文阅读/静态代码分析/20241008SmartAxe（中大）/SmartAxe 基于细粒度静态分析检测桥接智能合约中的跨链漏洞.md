---
title: SmartAxe：基于细粒度静态分析检测桥接智能合约中的跨链漏洞
date: 2024-10-07
tags: 
  - 静态代码分析
  - 区块链
categories: 
  - 论文阅读
---

# SmartAxe：基于细粒度静态分析检测桥接智能合约中的跨链漏洞

随着区块链的日益普及，不同的区块链平台在生态系统中共存（如以太坊、BNB、EOSIO等），这促使了对跨链通信的高需求。跨链桥接是跨不同区块链平台进行资产交换的一种特定去中心化应用。由于最近发生了多起因桥接智能合约漏洞引发的安全事故，造成了严重的财务损失，确保跨链桥接智能合约的安全成为了当务之急。我们称这些漏洞为`跨链漏洞（CCVs）`。然而，自动识别智能合约中的 CCVs 面临着独特的挑战。特别是，要做到以下两点并非易事：（1）识别资产交换所需的特定应用程序访问控制约束；（2）识别跨链桥接两端的跨链语义不一致性。

在本文中，我们提出了 SmartAxe，一种用于识别桥接智能合约中漏洞的新框架。`特别地，SmartAxe 旨在识别具有访问控制不完备性的漏洞函数。` SmartAxe 通过概率模式推断对访问控制的不同实现进行建模，找到智能合约中必要的安全检查。此外，SmartAxe 构建了跨链控制流图（xCFG）和数据流图（xDFG），以帮助在跨链数据通信过程中找到语义不一致性。为了评估 SmartAxe，我们收集并标注了来自真实跨链桥接智能合约的 88 个 CCV 数据集。评估结果表明，SmartAxe 的精度为 84.95%，召回率为 89.77%。此外，SmartAxe 成功识别了 232 新的或未知的 CCVs，这些漏洞来自 129 个真实跨链桥接应用程序中的 1,703 个智能合约。这些被识别的 CCVs 影响的数字资产总价值达到了 1,885,250 美元。

**CCS 主题概念**：

• 软件及其工程学 → 软件创建与管理；

• 软件创建与管理 → 软件验证与确认；

**附加关键词和短语**：智能合约，静态分析，跨链桥接，漏洞发现

## 引言

区块链的兴起促使了广泛的区块链平台（例如，以太坊 [Ethereum 2015]、BNB [Binance 2022]）和加密资产（例如，比特币 [Bitcoin 2009]、非同质化代币 [Wikipedia 2023]）的发展。在如此高度多样化且分散的生态系统中，跨越不同区块链平台的数据通信需求（例如，以太币和比特币的交换）变得至关重要。

跨链桥接是一种特定类型的应用程序，作为跨不同区块链进行信息交换（例如，数字资产）的中介。例如，Polygon 网络桥接 [Polygon 2023] 是最流行的跨链桥接之一，持有超过 20 亿美元的资产，允许用户在不依赖不受信任第三方的情况下在 Polygon 和以太坊区块链之间转移代币。尽管获得了数十亿美元的市值 [Chainspot 2023]，跨链桥接仍面临新兴的安全问题。我们的调查显示，在过去两年里，跨链桥接经历了超过 29 起安全事件。大部分跨链桥接的安全事件是由智能合约中的漏洞引起的。例如，PolyNetwork [Network 2020] 就因访问控制漏洞而被利用，导致 6 亿美元的损失 [Wikipedia contributors 2022]。

在本文中，我们将特定于跨链桥接智能合约的漏洞称为 **跨链漏洞** （Cross-Chain Vulnerability, CCV）。CCV 是跨链场景中独有的漏洞（即资产交换）并由智能合约实现。例如，尽管 CCV 的根本原因可能是缺乏细粒度的访问控制，但在其他传统智能合约中，访问控制的执行并非必要。另一个例子是，CCV 可能由桥接两端的语义不一致引起（参见第 2.2 节了解更多细节）。

鉴于 CCV 的严重影响，目前针对 CCV 的研究非常有限，更不用说针对保护跨链桥接的系统化检测框架了。更具体地，已有研究 [Duan et al. 2023; Lee et al. 2023] 旨在理解跨链攻击的关键模式。基于他们的观察和发现，提出了一系列对跨链开发者的缓解建议。然而，不幸的是，这些建议无法直接应用，也无法通过现有的跨链桥接进行强制实施。目前最相关的工作是 Xscope [Zhang et al. 2022]，它可以通过异常检测识别 CCV。然而，Xscope 需要分析链上交易的统计数据。在此条件下，它只能检测已经被攻击者利用的 CCV。

**我们的工作**

在本文中，我们提出了 SmartAxe，这是一种新的静态分析框架，用于检测跨链桥接智能合约中的 CCVs。根据我们所知，SmartAxe 是首个通过字节码级别的程序分析来检测 CCVs 的工具。通过这一功能，SmartAxe 可以在跨链桥接应用部署之前进行自动化的安全审核，从而提高其安全性，并减少可能导致严重损害（如财务损失）的潜在风险。

CCVs 的根本原因有两个方面：1）访问控制不完整性；2）跨链语义不一致性。识别桥接合约中的 CCVs 在静态分析方面面临以下两个独特的挑战：

* 首先，识别访问控制不完整性依赖于对访问控制约束的精确提取。访问控制约束包括对特定资源（例如，智能合约中的关键状态变量）进行适当的安全检查。不幸的是，这些安全检查在桥接合约中是异构实现的。此外，将相关资源与这些安全检查关联起来也带来了很大的复杂性。
* 其次，识别跨链语义不一致性很大程度上依赖于对跨链通信相关的细粒度上下文信息进行分析。例如，检查跨多个区块链的控制流和数据流依赖性。大多数现有框架 [Liao et al. 2023; Liu et al. 2021; Tsankov et al. 2018] 在检测智能合约漏洞时忽视了这些信息。

为了实现这一目标，SmartAxe 在其静态分析过程中集成了两个关键设计来检测 CCV。首先，SmartAxe 建模了桥接合约中访问控制的异构实现形式，将其转化为规范形式，以识别跨链桥接中所需的安全检查。同时，SmartAxe 通过概率模式推断，精准定位需要安全检查的跨链相关资源（参见 4.2 节）。通过这种方式，SmartAxe 能够有效发现具有访问控制不完整性的漏洞函数。其次，为了建模上下文信息，SmartAxe 对桥接两端的控制流和数据流进行对齐，并进一步构建了跨链控制流图（xCFG）和数据流图（xDFG）（参见 4.3 节）。通过这些构建的图，SmartAxe 定位了跨链数据通信中包含语义不一致的漏洞函数。最后，SmartAxe 分析了漏洞函数的可访问性（即入口点）和颠覆性（即受影响的状态变量），并报告了漏洞跟踪（参见 4.4 节）。

为了评估 SmartAxe 的有效性，我们首先构建了一个基于 22 个公共报告的手动标注数据集（记作 D_manual），这些报告讨论了 CCV。该数据集由 16 个跨链桥接应用组成，包含来自 203 个智能合约的 88 个 CCV。我们的实验表明，SmartAxe 在该数据集上的 CCV 检测精度为 84.95%，召回率为 89.77%。实验结果表明，SmartAxe 能够有效地检测到大部分导致实际世界损害的 CCV。

**在现实环境中检测 CCV**。借助 SmartAxe，我们对 1,703 个智能合约（来自 129 个真实跨链桥接应用）进行了大规模的安全审查。据我们所知，这是目前为止最全面的现实环境中的跨链桥接智能合约集合。最终，SmartAxe 报告了 232 个此前研究未发现的 CCV。这些 CCV 影响的数字资产总额达到 1,885,250 美元。

总结而言，本文的贡献如下：

* 我们指出了跨链漏洞的根本原因（参见第 2.2 节），包括访问控制不完整性和跨链语义不一致性。
* 我们提出了 SmartAxe，这是第一个用于检测跨链桥接智能合约中 CCVs 的静态分析框架。
* 我们进行了广泛的评估以展示 SmartAxe 的有效性。此外，通过对 1,703 个现实环境中的跨链桥接智能合约进行大规模研究，SmartAxe 在现实环境中识别出了 232 个新的 CCVs。
* 我们构建了首个跨链桥接漏洞的手动标注数据集，同时也是目前最全面的跨链桥接应用/智能合约数据集。为了推动未来研究的发展，我们公开了 SmartAxe 的工件及相应的数据集¹。

## 背景与动机

### 智能合约与跨链桥接

智能合约是一种在区块链上运行的特定类型的程序。这些程序支持各种功能以实现新的商业模式 [Zheng et al. 2020]，例如去中心化金融（DeFi）、去中心化游戏（GameFi）以及跨链桥接。

跨链桥接作为不同区块链平台上资产交换的中介。图 1 展示了跨链桥接的关键架构。典型的跨链桥接可以分为三个部分：源链、跨链中继器和目标链。跨链桥接在源链和目标链上部署智能合约。中继器则设计用于支持源链和目标链之间的信息交换。通过跨链桥接，用户可以在源链上存入资产并在目标链上提取资产。例如，图 1 中显示了用代币 A 交换代币 B 的场景。具体来说，该过程包括以下三个步骤：

1.	在源链上存入资产。当接收到用户的资产交换请求时，源链的路由合约 $R_s$ 调用代币合约 $T_s$ 锁定代币A。然后， $R_s$ 触发一个存入事件 $I_d$ ，作为锁定资产的确认，该事件包含了详细的存入信息（例如，类型和数量）。在此之后，用户的资产将被转移到路由合约 $R_s$ 。
2.	通过链下中继器进行跨链通信。一旦存入事件 $I_d$ 被触发，链下中继器验证该存入事件是否在源链上有效。如果验证通过，中继器将信息 $I_p$ 传输给目标链的路由合约 $R_d$。
3.	在目标链上提取资产。一旦 $I_p$ 被传递到目标链，路由合约 $R_d$ 验证来自 $I_p$ 的各种证明以进行授权。验证通过后， $R_d$ 触发提取事件 $I_w$ ，并调用代币合约 $T_d$ 从目标链上的用户指定地址中提取代币B。

<p style="text-align:center"><img src="./1.png" alt="bug"/></p>

<p style="text-align:center">图1. 跨链桥的工作流程</p>

### 定义与问题陈述

`跨链漏洞（Cross-Chain Vulnerability, CCV）`。跨链漏洞是一种特定类型的跨链桥接智能合约中的漏洞。在大多数情况下，当在两个区块链之间交换资产时，跨链桥接合约可能会引入不完整的访问控制或跨链语义不一致性。在接下来的部分中，我们使用两个实际的例子（图 2）来说明 CCV。这些例子是从两个被攻击者利用的真实世界桥接合约中收集的（即，ChainSwap [Sam Cooling 2021] 和 ThORChain [Sebastian Sinclair 2021]）。为了更好地说明问题，我们重新组织了原始的合约代码。

<p style="text-align:center"><img src="./2.png" alt="bug"/></p>

<p style="text-align:center">图 2. 两个跨链漏洞（CCV）的典型示例</p>

* 访问控制不完整性。跨链桥接合约可能会省略关键的安全检查，或包含不正确的访问控制实现。如图 2(a) 所示，合约 `ContextUpgradeSafe` 中的变量 `Quota` 代表签名验证（第 2 行），该验证应在资产授权与提取之前进行。然而，函数 `Receive` 设计用于资产授权与提取，但它仅检查签名而不验证签名者（即，检查 `Quota`，见第 6 和第 7 行的红色虚线框）。因此，该合约引入了一个可利用的 CCV。如路径 $P_c$ 所示，要攻击该跨链桥接，攻击者可以伪造虚假中继器（即签名者）进行签名（ $P_c-1$ ），并由于缺乏签名验证而绕过授权检查（ $P_c-3$ ），最终提取资产（ $P_c-4$ ）。在实际应用中，可以在第 6 到第 7 行之间添加语句（例如 `require (Quota[signatory] > 0)`）来避免此漏洞。
* `跨链语义不一致性`。理想情况下，源链和目标链的程序语义应保持一致，例如交换资产的类型和数量。图 2(b) 显示了由于错误的代币类型解析引起的语义不一致的一个示例。对于合约 `Chain_Router`，函数 `Deposit` 在源链上发出一条记录（第 4 行），表示代币类型为“ERC-20”。然而，函数 `Withdrawal` 中预期的默认代币类型为“ETH”（第 6 行）。虽然可以通过 `getTokenMeta(token)` 更新实际代币类型，但目标链上的智能合约并未仔细处理和检查异常情况。特别是，攻击者可以故意传递错误的代币地址（即 0x0000x）以使代币类型被错误地解析为默认值（“ETH”），而不考虑源链上实际代币类型。由于 ETH 的价值高于 ERC-20，攻击者可以从此类价值差异的资产交换中获益。

`现有工作及其局限性`。尽管 CCVs 已被广泛利用，但目前关于在攻击发生前识别此类漏洞并进一步消除相应损失的工作仍然有限。据我们所知，最相关的跨链攻击识别工作是 Xscope [Zhang et al. 2022]。然而，Xscope 是一个用于分析跨链交易的异常检测工具，并且不支持在智能合约层面检测 CCV。

此外，由于智能合约在部署后难以支持补丁更新，这样的框架无法避免攻击的发生，也无法进一步消除经济损失。此外，Duan 等人 [Duan et al. 2023] 和 Lee 等人 [Lee et al. 2023] 对跨链攻击进行了调研，并提出了跨链系统设计方面的建议，因此这两项研究都无法从根本上检测 CCV。

### 我们工作的范围

SmartAxe 被设计为一种通用框架，用于检测跨链桥接中由漏洞智能合约引起的 CCVs。SmartAxe 关注于桥接的上层应用（例如，桥接 Dapp），而非桥接的底层协议（例如，跨区块链通信协议 (IBC)）。作为一个程序分析框架，SmartAxe 能够涵盖 29 起跨链安全攻击中的 20 起 CCV 攻击，但不包括其他 9 种与智能合约代码无关的跨链漏洞利用，例如私钥泄露 [Rubic 2022]、DNS 劫持 [CelerNetwork 2022] 以及可信根泄露 [Behnke 2022]。在一组跨链桥接应用程序的智能合约上，SmartAxe 对字节码进行静态分析，并进一步报告该智能合约是否包含 CCV。由于 SmartAxe 针对字节码而非源代码进行分析，因此其适用于大规模第三方审计等多种安全审查场景。

## SmartAxe 设计

### 挑战与解决方案

随着跨链智能合约复杂性的增加，识别 CCVs 绝非易事。尽管此前的研究对智能合约中的访问控制漏洞进行了分析（例如，Ethairter [Brent et al. 2020]、SPCon [Liu et al. 2022]、AChecker [Ghaleb et al. 2023]），但这些研究从未考虑跨链场景下的安全假设，因此难以检测到 CCV。以下是 SmartAxe 遇到的挑战以及相应的解决方案。

`C1：提取访问控制约束`。典型的访问控制约束通常由智能合约中特定资源的安全检查组成。具体而言，安全检查可以是条件语句或比较语句（例如 `require`、`assert` 和 `if`），资源可以是对重要操作语句（例如，状态变量的读写、方法调用）的依赖。从这一角度看，提取访问控制约束的挑战可以分为两个方面。

<p style="text-align:center"><img src="./3.png" alt="bug"/></p>

<p style="text-align:center">图 3. 存款成功的安全检查多样性示例（即，第 3 行和第 12 行），该多样性是由不同实现方式和非标准检查引起的，并且无法通过 Ethainter [Brent et al. 2020]、SPCon [Liu et al. 2022] 和 AChecker [Ghaleb et al. 2023] 来解决。</p>


第一个方面是安全检查的多样性，这种多样性由不同实现方式和非标准检查引起。例如，图 3 展示了不同跨链桥接中安全检查的多样实现方式。如图所示，为检查存款是否成功，合约 `Radar` 比较用户余额和存款金额（第 3 行），而合约 `Polkabridge` 将桥接的流动性与阈值进行比较（第 12 行）。然而，先前的研究（例如，Ethairter [Brent et al. 2020]、SPCon [Liu et al. 2022]、AChecker [Ghaleb et al. 2023]）无法解决这种多样性，因为它们的检测模式在没有考虑桥接语义的情况下是不完整的。

<p style="text-align:center"><img src="./4.png" alt="bug"/></p>

<p style="text-align:center">图 4. 一个展示将资源与安全检查关联时复杂性的示例</p>


第二个方面是将资源与安全检查链接起来的内在复杂性。我们以图 4 为例。对于第 12 行的资源，以往的研究 [Brent et al. 2020; Ghaleb et al. 2023; Liu et al. 2022] 将该资源与依赖第 5 行的安全检查相关联，而忽略了第 8 行的检查，这导致了错误的结果。实际上，通过对这些语义的分析，我们发现第 14 行的资源转移了授权签名的控制权，第 5 行的检查对应授权签名，第 7 行的检查则对应授权检查，因此第 5 和第 7 行的所有检查都应该与第 12 行的资源相关联。或者，通过分析第 8、9 和 11 行的依赖关系，我们也可以确定第 7 行的检查应该与第 12 行的资源相关联。然而，自动识别这些检查绝非易事，因为这需要对复杂的模式和数据依赖关系进行深入分析。

为了解决这一挑战，为识别安全检查，我们审查了前 100 个跨链桥接的文档和程序代码，并将跨链桥接的访问控制建模为规范形式（详见表 1 和第 4.2 节）。为了将资源与安全检查关联起来，SmartAxe 使用了概率模式推断方法（详见表 2 和第 4.2 节）。具体而言，SmartAxe 利用了一组预定义模式，这些模式考虑了资源与安全检查之间在控制流、数据流和语义上的依赖关系，从而确定它们之间的关联关系。

此外，基于提取的访问控制约束，SmartAxe 识别桥接合约的访问控制不完整性。

`C2: 识别跨链语义不一致性`。与单个区块链上的漏洞分析不同，跨链语义不一致性 CCV 的识别在很大程度上依赖于对跨链数据传输过程中上下文信息的建模（例如，发出 $I_d$ ，中继器告知 $I_p$ ）。识别上下文信息绝非易事，因为这需要跨链桥接两端的控制流和数据流的精确对齐，而这在现有的研究中尚未被充分支持。此外，很难识别控制流和数据流对齐的位置，因为定位对齐点需要进行细粒度的语义和控制流分析。

为了解决第二个挑战，SmartAxe 通过细粒度的语义和控制流分析，识别了两种类型的函数作为对齐点，即：（1）实现存入和锁定的函数；（2）实现授权和提取的函数。随后，SmartAxe 对相应的对齐点进行对齐，并构建了跨链控制流图（xCFG）。为了便于检测 CCV 的跨链语义一致性，SmartAxe 对 xCFG 进行数据流分析，从而构建跨链数据流图（xDFG）。

此外，基于构建的 xCFG 和 xDFG，SmartAxe 识别了桥接合约中跨链语义不一致的 CCV。

### SmartAxe 的工作流程

SmartAxe 以跨链桥接合约的字节码作为输入，最终报告其是否包含 CCV 及相应的漏洞追踪。漏洞追踪包含从漏洞函数到受污染的状态变量的函数调用，这些状态变量可能受到外部调用的影响。图 5 展示了 SmartAxe 的工作流程。

<p style="text-align:center"><img src="./5.png" alt="bug"/></p>

<p style="text-align:center">图 5. SmartAxe 的工作流程</p>

S1. `基本控制流分析`。作为静态分析的典型过程，SmartAxe 分别恢复跨链桥接两端智能合约的控制流，作为预处理步骤，通过现有的分析器（例如，我们研究中的 SmartDagger [Liao et al. 2022]）来实现。

S2. `访问控制完整性识别`。在第二步中，SmartAxe 基于基本的控制流信息识别所有访问控制约束。特别地，SmartAxe 对桥接合约的访问控制进行建模，并将不同的检查规范化为标准形式。然后，SmartAxe 执行概率模式推断，将资源与安全检查关联起来。基于提取的访问控制约束，SmartAxe 识别出包含访问控制不完整性的漏洞函数。

S3. `跨链语义不一致性识别`。SmartAxe 对源链和目标链之间智能合约的控制流进行对齐，以构建跨链控制流图（xCFG）。进一步地，SmartAxe 执行数据流分析以构建跨链数据流图（xDFG）。基于构建的图，SmartAxe 识别出包含语义不一致的漏洞函数。

S4. `通过污点分析发现漏洞追踪`。最后，基于 S3 和 S4 中报告的漏洞函数，SmartAxe 通过污点分析识别所有的漏洞追踪。

## 方法细节

在本节中，我们展示了 SmartAxe 中每个步骤的具体细节。同时，我们使用一个运行示例（即图 2）来说明 SmartAxe 如何准确识别 CCV。

### 基本控制流分析

SmartAxe 通过利用最先进的静态分析工具 SmartDagger，分别从给定跨链桥接两端的智能合约字节码中构建基本控制流。SmartAxe 使用 SmartDagger，该工具专为识别跨合约漏洞而开发，因为 SmartDagger 能够比其他静态分析工具（例如，Slither [Feist et al. 2019] 和 Mythril [Consensys 2017]）构建更完整的跨函数（合约）调用控制流。具体而言，对于跨链桥接的每一端，SmartDagger 从桥接合约的字节码中构建控制流图。

### 访问控制不完整性识别

在本小节中，SmartAxe 通过对访问控制的安全检查进行建模，并将资源与安全检查关联起来，从而提取访问控制约束。基于提取的访问控制约束，SmartAxe 识别了访问控制的不完整性。

`建模异构安全检查`。如前所述，跨链桥接的工作流由三个步骤组成：（1）资产存入与锁定；（2）跨链通信；（3）资产授权与提取。桥接合约的安全检查本质上是根据这三个工作流来强制执行用户的权限。然而，跨链桥接中安全检查的实现方式实际上更加多样化。这是因为不同的跨链桥接通常使用不同类型的安全特性，这些安全特性与这些工作流相关联，从而实现访问控制的安全检查。因此，我们需要识别、建模并规范所有这些各种形式的访问控制检查，以便进行比较。

安全检查的建模基于以下事实：尽管大多数安全检查在语法形式上有所不同，但在提供的保护方面，它们在语义上是等效的。SmartAxe 采用了此前研究 [Aafer et al. 2018] 中提出的等效性定义。我们对等效性的定义是关于安全检查所提供的保护，即安全检查所防范的恶意行为。我们参考图 3 以说明这一点，第 3 行和第 12 行的安全检查从语法形式上来看是不同的。然而，从它们提供的保护角度来看，它们是等效的，因为第 3 行的检查确保了存款成功所需的足够余额，而第 12 行的检查则确保了存款成功所需的足够流动性。

为了在跨链桥接智能合约中建立必要的访问控制机制，我们从 Chainspot [Chainspot 2023] 收集了前 100 名桥接 Dapp，这是一个区块链桥接聚合的网站。我们的领域专家仔细审查了这些 Dapp，以辨别其智能合约中嵌入的所有安全检查。根据桥接的工作流，我们的领域专家相应地对这些安全检查进行分类。对于每个类别，他们进一步根据目标保护区域对其进行区分层次化处理。随后，他们提供了相应安全特性及其应用的综合摘要。

表 1 展示了我们总结的访问控制安全检查模型。SmartAxe 将访问控制的安全检查分为三类：（1）特定于资产存入与锁定的类别，（2）特定于跨链中继的类别，以及（3）特定于资产授权与提取的类别（即第一列）。因此，我们提出了对桥接合约安全检查进行如下建模：
$$
BridgeCheck := [DepositandLock, CrosschainRouter, Authorizationandwithdrawal] (1)
$$

<table border="1">
    <caption>表 1. 跨链桥合约访问控制的安全检查模型</caption>
    <tr>
        <th>类别</th>
        <th>视角</th>
        <th>安全特性</th>
        <th>使用示例</th>
    </tr>
    <tr>
        <td rowspan="5">C1. 资产存入和锁定</td>
        <td rowspan="3">P1. 存款成功检查</td>
        <td>存款后的桥接余额</td>
        <td>与存款前的余额对比</td>
    </tr>
    <tr>
        <td>用户余额</td>
        <td>与存款金额比较</td>
    </tr>
    <tr>
        <td>桥接流动性</td>
        <td>与存款阈值比较</td>
    </tr>
    <tr>
        <td rowspan="2">P2. 用户参数验证检查</td>
        <td>公共函数的参数</td>
        <td>与逻辑条件比较</td>
    </tr>
    <tr>
        <td>用户消息的参数</td>
        <td>与逻辑条件比较</td>
    </tr>
    <tr>
        <td rowspan="2">C2. 跨链中继</td>
        <td rowspan="2">P3. 跨链中继正确性检查</td>
        <td>桥接支持的代币/链</td>
        <td>与目标链 ID 比较</td>
    </tr>
    <tr>
        <td>外部调用地址</td>
        <td>与 0 地址比较</td>
    </tr>
    <tr>
        <td rowspan="4">C3. 资产授权与提取</td>
        <td rowspan="2">P4. 验证检查</td>
        <td>签名与签名者</td>
        <td>与跨链消息比较</td>
    </tr>
    <tr>
        <td>签名超时时间</td>
        <td>与链上时间状态比较（例如时间戳、区块号）</td>
    </tr>
    <tr>
        <td>P5. 重复提取检查</td>
        <td>提取记录列表</td>
        <td>查询列表（即映射变量）</td>
    </tr>
    <tr>
        <td>P6. 释放正确性检查</td>
        <td>接收者地址</td>
        <td>与用户指定地址或 0 地址比较</td>
    </tr>
</table>

`类别 1 - 资产存入与锁定`：该类别包括存入和锁定的成功检查，以及用户传递的参数的验证检查（即第二列的前两个条目）。具体来说，存款的成功检查用于确认存款已转移到跨链桥接中，从而防止伪造存款。用户传递参数的验证检查用于防止用户传递恶意参数，这些参数可能会对合约状态进行恶意修改。如第三列前三个条目所示，每个视角的安全检查可以采用多种形式，例如比较存款前后桥接的余额、比较用户余额与存款金额、或将桥接的流动性与存款阈值进行比较。尽管这三种安全检查在语法形式上有所不同，但在确认存款成功方面，它们在语义上是等效的，因此它们之间存在一种析取关系。此外，在第三列的第四和第五个条目中，参数的验证检查可以通过检查公共函数和消息调用的参数（例如 `msg.sender`, `msg.value`）来实现。同样，这两种类型的安全检查在语义上是等效的，因此它们之间也存在一种析取关系。我们进一步将上述理解表述如下。

$$
DepositandLock := [DepositSuccess, Argument] (2)
$$

$$
DepositSuccess := check(BridgeBalance) ∧ check(UserBalance) ∧ check(AssetOwnership) (3)
$$

$$
Argument := check(FunctionArgument) ∧ check(MessageArgument) (4)
$$