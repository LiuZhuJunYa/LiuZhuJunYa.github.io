---
title: 你所有的代币都属于我们：揭秘Solidity智能合约中的地址验证漏洞
date: 2025-03-30
tags: 
  - 静态代码分析
  - 区块链
  - 智能合约
  - 以太坊
  - 合约缺陷检测
  - 字节码分析
  - 符号执行
categories: 
  - 论文阅读
---

# 你所有的代币都属于我们：揭秘Solidity智能合约中的地址验证漏洞

## 摘要

在以太坊（Ethereum）中，验证传入地址的有效性是一种常见做法，这是确保智能合约安全执行的关键步骤。地址验证过程中的漏洞可能会带来严重的安全问题，并且社区中也已有一些零散的报告。然而，这类漏洞尚未得到充分研究。为填补这一空白，本文旨在刻画并检测此类新兴的漏洞。

我们设计并实现了**AVVERIFIER**，这是一种基于静态 EVM 操作码模拟的轻量级污点分析器（taint analyzer）。该分析器包含三阶段检测机制，能够基于漏洞本身的内在特性逐步排除误报和漏报。基于一个成熟且客观的基准测试，**AVVERIFIER**在效率方面可比现有最先进方法（SOTA）提升 2 倍至 5 倍，同时仍保持 94.3% 的精确率与 100% 的召回率。

在对超过 500 万个以太坊智能合约进行的大规模评估中，我们发现了 812 个此前尚未被社区披露的易受攻击智能合约，并对其中 348 个开源合约进行深入验证，其最大锁定总价值（TVL）超过 112 亿美元。随后我们将 **AVVERIFIER** 部署为以太坊和币安智能链（Binance Smart Chain）上的实时检测器，结果表明，一旦合约部署，**AVVERIFIER**即可及时发出警告。

## 引言

在中本聪发布比特币 [57] 后，各类区块链平台如雨后春笋般涌现。其中，最为知名的平台当属以太坊 [17]。除了区块链平台共有的一些通用特性外，以太坊最引人注目的特性便是智能合约。它可以被视作一段不可更改的脚本，一旦满足预定义条件，就将以确定的方式执行。

由于智能合约中存储了价值数十亿美元的资产，发现并利用合约中潜在漏洞成为攻击者的首要目标。根据一份近期报告 [65]，在过去一年间，已有大约 303 次针对知名以太坊合约的大规模攻击事件，造成了约 38 亿美元的损失。Chen 等人 [19] 总结了以太坊智能合约中的 26 类主要漏洞；然而，随着以太坊不断地加入新特性、废弃旧特性 [45]，新的漏洞类型也在不断涌现。

针对以太坊智能合约漏洞的自动化识别已是一个研究热点 [14,35,44,53,67,69,75]。考虑到合约数量庞大以及由漏报（false negative）带来的潜在经济损失，静态符号执行往往被采用为主要分析方法，因为它可以在一定程度上保证完备性。例如，Mythril [67] 是一款面向以太坊合约字节码层面的静态符号执行器，而 Slither [29] 则针对源代码进行工作，并宣称能在效率与有效性方面取得优异表现。

验证输入地址的有效性是一种常见做法，同时也是确保智能合约安全执行的关键步骤。在地址验证过程中，如果出现漏洞，就可能导致严重的安全问题。我们社区 [11] 中已有一些零散的报告提到此类问题。具体而言，智能合约中的函数可能会被当作参数来调用。如果开发者在传入地址时疏忽了验证，一旦该地址被用作外部调用的目标，那么该地址对应的任意操作（包含恶意操作）都可能被执行。因此，如果合约对链上状态的修改依赖该外部调用，则可能造成与开发者本意相悖的操作。

目前尚无现有工具可检测地址验证漏洞，并且想要基于现有框架实现此类检测器也极具挑战。一方面，根据地址验证漏洞的特点，为有效识别，该检测器应进行跨过程甚至跨合约分析；但已有工作在执行此类分析时或多或少地遭遇效率与有效性之间的难题。例如，基于模式匹配的检测方法难以处理如此复杂的漏洞模式，而符号执行则面临路径爆炸以及约束求解带来的瓶颈。另一方面，大多数合约并未开源，而字节码本身缺乏足够的语义信息，导致难以准确识别隐藏漏洞。尤其是，对于地址验证漏洞，需要在内存和存储区域进行细粒度的跟踪。然而在字节码级别，很难区分这两个区域中不同的变量。而使用符号执行来追踪它们，会因为可行插槽数量巨大而产生严重的路径爆炸问题。

**本研究工作（This work）。** 为填补这一空白，我们聚焦刻画并检测此类新兴的漏洞。具体而言，我们设计并实现了 **AVVERIFIER**，这是一种新颖且轻量级的静态污点分析框架，能够高效且有效地识别地址验证漏洞。它采用基于操作码序列的静态模拟方式来执行污点分析。也就是说，在不考虑路径可行性的前提下，AVVERIFIER 维护数据结构（例如栈和内存）的数值以及相应的污点传播状态。这种静态模拟能够遍历大量路径，包括原本不可行的路径。依托于收集到的对应状态，AVVERIFIER 通过三阶段检测正式识别地址验证漏洞，并能基于漏洞的内在特性逐步排除误报和漏报。

在我们精心构造的基准测试中，AVVERIFIER 在效率和有效性方面都远胜于当前业界先进的智能合约检测工具（如 Mythril、Ethainter、Jackal 和 ETHBMC）¹。基于对超过 500 万个已部署以太坊合约的综合评估，AVVERIFIER 发现了 812 个存在漏洞的合约，其中 348 个开源智能合约经进一步验证，锁定总价值（TVL）超过 112 亿美元。最后，我们将 AVVERIFIER 部署在以太坊和 BSC（另一个类似 EVM 的区块链平台）上用作实时检测器。结果表明，一旦合约部署，AVVERIFIER 就能及时向开发者和社区发出预警；其中一例真实案例显示，AVVERIFIER 比实际攻击发生早 1.5 小时发出警告，证明了其有效性和高效性。

**本文的主要贡献如下：**

- 这是首个对地址验证漏洞进行检测的工作。我们设计并实现了 AVVERIFIER，这是一种基于静态 EVM 模拟的高效且有效的污点分析器。
- 我们在超过 500 万个以太坊智能合约上运行了 AVVERIFIER，发现了数百个此前未被社区披露的易受攻击合约。这也是对该类漏洞进行大规模野外研究的首个尝试。
- 与 Mythril、Ethainter、Jackal 和 ETHBMC 相比，AVVERIFIER 在效率上大约可提升 2 倍到 5 倍，同时在成熟基准测试上达到了 94.3% 的精确率和 100% 的召回率。
- 我们已将 AVVERIFIER 作为实时检测器部署于以太坊与 BSC。结果显示，只要合约一经部署，AVVERIFIER 即可在攻击者动手前及时发出预警。

## 背景

### 以太坊简介

在以太坊中存在两种类型的账户：外部拥有账户（external owned account，EOA）和智能合约。具体而言，EOA 是一个普通账户，通过唯一地址进行标识并由私钥控制。而智能合约可被视作脚本，主要使用 Solidity [26] 编写，这是一种由以太坊官方提出、定义明确且易于使用的编程语言。账户之间的交互通过发起包含相应数据的交易来实现。智能合约的执行环境是嵌入在以太坊客户端节点中的以太坊虚拟机（EVM）[41]。EVM 采用基于栈（stack-based）的结构，所有数据都会被永久或临时地保存。具体而言，各种操作符的操作数以及中间值会被压入或弹出栈。内存区（memory area）[40] 属于临时存储，只在当前交易的上下文中保持数据；只有存储区（storage area）[53] 中的数据才是永久存储，也就是存储在链上。我们通常把一组协同完成某项特定功能的智能合约称为去中心化应用（DApp）。

自 2016 年开始，DApp 就展现出了显著的潜力 [38]。目前已出现了多种类型的 DApp，例如博彩 [58]、代币交换 [73] 和借贷 [68] 等。伴随着数百亿美元涌入以太坊，去中心化的传统金融工具（如交易所和保险）开始出现，我们称其为去中心化金融（DeFi）。DeFi 充分利用了以太坊的去中心化、无需许可以及透明等特性，得以迅速崛起。根据统计，截至 2022 年底，DeFi 的规模达到了 1630 亿美元 [51]。

除了官方代币 Ether 以外，以太坊允许用户自由发行符合 ERC-20 [60] 等标准的代币。ERC-20 标准包含六个必需函数，任何实现了这些函数的智能合约都能发行可以在以太坊中流通的有效代币，如 USDT [15] 和 USDC [9]。因此，DeFi 也能发行自有的 ERC-20 代币，并且将其他 ERC-20 代币视为有效资产。ERC-20 代币与 DeFi 之间的互操作性极大地推动了以太坊生态的繁荣。

### 白名单地址验证

在以太坊中，检查给定地址的有效性是一种常见做法，称为白名单地址验证（whitelisted address verification）。它在诸如借贷 [74] 和银行 [6] 等 DeFi 应用中被广泛采用。地址验证是保证智能合约安全的基石。因此，以太坊社区知名的标准库提供方 OpenZeppelin [61] 也提供了白名单验证方法。此外，我们对 TVL（锁定总价值）[50] 排名前 40 的 DeFi 项目进行了深入研究，这些项目占据了整个 DeFi 市场 95% 以上的份额，并总结了它们使用的验证技术。简言之，它们主要使用了三种白名单验证方法：硬编码对比（hard-encoded comparison）、映射验证（mapping validation）以及硬编码地址枚举（hard-encoded address enumeration）。需要说明的是，尽管我们无法保证涵盖所有已采用的地址验证技术，但以上三种是最为普遍的。再考虑到以太坊智能合约里“复制并使用” [38] 的广泛现象，这三种机制具有代表性。

```solidity
1 function deposit(uint256 amount, address token) external {
2     require(token == usdt, "not usdt token!");
3     token.safeTransferFrom(msg.sender, address(this), amount);
4 }
```

<p style="text-align:center">Listing 1：硬编码地址对比</p>

**Listing 1** 演示了硬编码对比的工作方式。可见，第 2 行要求传入的 `token` 地址必须与 `usdt` 地址相等，否则将抛出异常。映射验证方法则采用一个映射结构来动态维护地址的白名单状态，例如 `mapping(address => bool) whitelist`。至于硬编码地址枚举，它是第一种方法的变体。

```solidity
1 address[] public addresses;
2
3 function contains(address _address) public view returns (bool) {
4     for(uint i = 0; i < addresses.length; i++) {
5         if (addresses[i] == _address) {
6             return true;
7         }
8     }
9     return false;
10 }
11
12 function deposit(uint256 amount, address token) external {
13     require(contains(token), "not contain this token");
14     token.safeTransferFrom(msg.sender, address(this), amount);
15 }
```

<p style="text-align:center">Listing 2：硬编码地址枚举</p>

如 **Listing 2** 所示，一个名为 `addresses` 的数组保存了所有白名单地址。因此，一旦调用 `deposit` 函数，传入的 `token` 会被送至 `contains` 函数（在第 3 行 L3 定义），该函数本质上是以循环为外层、封装好的硬编码对比。在字节码层面，这三种方法执行逻辑相似。合约会通过 `CALLDATALOAD` 将参数中的地址加载进来，并通过条件操作码 `JUMPI` 进行验证。如果地址通过白名单检查，控制流就会进入默认的执行分支（fallthrough branch）并继续执行后续逻辑；否则，会跳转至 `jumpdest` 分支，处理验证失败的情形。

### 智能合约中的污点分析
 污点分析是一种程序分析的基础方法，可用于检测漏洞 [32] 和追踪敏感信息流动 [44]。在执行污点分析前，需要明确定义源（source）和汇（sink）：其中，源指由对手可控的输入字段，汇则是系统中可能以不安全方式使用潜在危险数据的任何地方。通过污点分析，可以跟踪从源到汇的数据流，并识别数据在传输过程中的所有操作或变换。

在以太坊智能合约的语境下，源通常是接受来自其他账户交易的智能合约函数；而汇会根据具体目标而异。例如，为了检查合约是否可被销毁，Ethainter [14] 将 `SELFDESTRUCT` 操作码作为汇。此外，Michael 等人 [32] 引入了一种基于符号执行和污点分析的工具，并将 `SSTORE` 设定为主要汇进行评估。

### 威胁模型

 在本研究中，对手不需要任何额外权限。原因在于以太坊是一个无需许可（permissionless）的区块链平台，任何没有特殊权限的账户（包括恶意账户）都能在具备足够 `gas` 的前提下发起交易、部署合法的智能合约并调用已部署的合约。当然，对手仍面临一些限制。例如，他们无法破坏以太坊网络的完整性或操纵区块生成过程，也无法获取合法账户的私钥。总的来说，我们几乎无法在区块链层面区分对手与表现正常的账户。

## 动机示例与挑战

### 动机示例

```solidity
1 function deposit(
2   uint256 visrDeposit,
3   address payable from,
4   address to
5 ) external returns (uint256 shares) {
6   require(visrDeposit > 0, "deposits must be nonzero");
7   require(to != address(0) && to != address(this), "to");
8   require(from != address(0) && from != address(this),
    "from");
9
10   shares = visrDeposit;
11   if (vvisr.totalSupply() != 0) {
12     uint256 visrBalance = visr.balanceOf(address(this));
13     shares = shares.mul(vvisr.totalSupply()).div(visrBalance);
14   }
15
16   if(isContract(from)) {
17     require(IVisor(from).owner() == msg.sender);
18     IVisor(from).delegatedTransferERC20(address(visr),
         address(this),
         visrDeposit
     );
19   }
20   else {
21     visr.safeTransferFrom(from, address(this),
         visrDeposit
     );
22   }
23
24   vvisr.mint(to, shares);
25 }
```

<p style="text-align:center">Listing 3：vvisr 中存在漏洞的存款功能</p>

**Listing 3** 展示了一个由 Visor Finance 所拥有的智能合约，该合约存在地址验证漏洞，并于 2021 年 12 月 21 日遭到攻击 [11]，造成 820 万美元的经济损失。可以看到，`deposit` 函数接收三个参数：要存入的代币数量（`visrDeposit`）、付款方（`from`）以及收益方（`to`）。在第 6～8 行对传入参数进行合理性检查，包括存入数量是否有效，以及付款和收款地址是否合法。接下来根据 `totalSupply()`（第 11～14 行）将存款转换为份额，从 `from` 地址向合约自身转移相应代币（第 16～22 行），并向 `to` 地址铸造（mint）一定数量的 `vvisr` 代币（第 24 行）。漏洞隐藏在第 16 行开始的 `if` 代码块中。具体来说，该合约允许 `from` 地址是一个合约地址，并检查其 `owner` 函数是否返回交易发起者的地址（第 17 行）。若该断言通过，则会调用 `from` 中定义的 `delegatedTransferERC20` 函数。回想在 §2.4 中提到的威胁模型，攻击者可以随意地部署合约并发起交易。更准确地说，如果 `from` 实际上是由恶意方提供的合约地址，那么他们就能控制第 17 和第 18 行的行为，从而顺利让控制流执行到第 24 行；此时，`vvisr` 会将代币铸造给 `to` 地址（也由攻击者控制），而预期中应由 Visor Finance 开发者设想的代币转移却没有实际发生。

通过这个示例，我们可以总结出与地址验证漏洞相关的三条基本原则：

- **P1**：存在一个易受攻击的函数，该函数接收一个地址作为参数，但对该地址的授权检查不足。攻击者可传入自部署且未经授权的合约地址。
- **P2**：在 **P1** 中提到的地址会被当作外部调用的目标。通过这个外部调用，控制流实际上转移给了攻击者。这样一来，攻击者可以完全控制这次外部调用的行为，包括其返回值。
- **P3**：区块链上（on-chain）的状态更新依赖于 **P2** 中返回值的控制流。也就是说，通过这种未经授权的控制流，攻击者能够通过间接操纵链上状态（例如发起外部调用或更新余额）来牟取利益。

### 挑战

针对地址验证漏洞（§3.1 中的动机示例与总结原则），我们识别出以下挑战：

**C1：语义缺失（Lack of semantics）。**
 由于字节码缺乏足够的语义信息，很难准确判断 P1 中提到的地址是否已被充分验证。根据统计 [56]，超过 99% 的以太坊合约并未公开源代码。字节码格式可读性极差，且几乎不包含可用于理解其功能的语义信息。此外，也没有调试信息可用于帮助恢复这些语义。传统基于字节码的分析工具通常需要一些方法来应对这一难题，例如符号执行 [67]。

**C2：跨过程的控制流与数据流分析（Inter-procedural analysis on control flow and data flow）。**
 要检测此漏洞，需要在跨过程的层面上精确提取控制流和数据流依赖关系。具体而言，在 P2 中，对一个由函数参数传入的地址进行外部调用；在进行外部调用和函数入口之间，地址会因为各类授权验证而被多次传递。因此，我们必须通过数据流分析来确定被调用地址是否确实来自函数参数。此外，在 P3 中，区块链状态的更新取决于 P2 中外部调用的返回值在控制流上的影响，这就要求我们识别变量之间的控制流依赖关系。另外，从 **Listing 2** 可以看出，一些授权逻辑可能出现在其他函数中，也需要跨过程分析加以识别。

### 现有工具的局限性

在实现一个轻量级且有效的地址验证漏洞检测器时，我们排除了采用动态分析的工具。主要原因有两点：

1. 动态分析需要在运行时环境下执行，既占用大量资源，又耗时较长，与我们的“轻量级”目标相悖。
2. 动态分析需要配合自动化生成的测试用例和判定条件（oracle）来发现漏洞。对于复杂合约（尤其是需要跨合约分析的场景），这种方法可能无法覆盖所有有漏洞的路径，从而导致漏报。因此，我们更倾向于静态方法，包括基于模式匹配的检测、符号执行以及污点分析。

就我们所知，目前还没有任何工具能直接用于检测此类漏洞。即便对其进行扩展以支持该功能，依然会面临一些内在限制。

**基于模式匹配的检测（Pattern-based Matching）。**

这类方法依赖开发者总结的启发式规则。许多早期的工具都采用此方法，通过操作码序列 [35]、交易历史 [5] 以及调用轨迹 [21] 等特征来识别漏洞。然而，这是一种人为定义的过程，既不完备也易出错，甚至难以解决 C1（如何在字节码序列中识别精确语义）。同时，Solidity 语法 [72] 与编译工具链 [28] 的持续更新也让此类工具在实际应用中往往失效。

**符号执行 & 模型检测（Symbolic Execution & Model Checking）。**

这两种技术在软件分析领域被广泛应用于识别漏洞。通过对程序进行抽象，符号执行器和模型检测工具可以恢复部分语义信息，从而在一定程度上克服 C1。但它们本质上受到效率问题的制约，主要原因是路径或状态爆炸。以 **Listing 3** 中的示例为例，这类工具不仅需要从入口遍历所有可能的函数来定位类似 `deposit` 的函数逻辑，还会在第 16～18 行卡住：它们会尝试所有可能的合约，因为无法高效地进行跨合约乃至跨过程的分析，故 C2 成为其应用的主要障碍。此外，这些工具通常会对内存（memory）进行十分精细的建模（逐比特考虑），虽有助于保持分析结果的完备性，却大大牺牲了效率。在地址验证漏洞的场景中，我们只需要关注地址参数在内存中的传播，而无需对具体数据进行如此精确的建模。

**污点分析（Taint Analysis）。**

现有的污点分析器还无法直接用于检测此漏洞。首先，其中一些工具依赖源代码 [29]；而在以太坊中，此类开源合约不到 1%。其次，一些工具受其收集与跟踪污点传播方式的限制。比如，Sereum [63] 基于动态分析监控运行时；Mythril [67] 和 Osiris [70] 都采用符号执行收集静态信息，其中 Mythril 会尝试遍历所有可行路径，而 Osiris 仅限于函数内分析（intra-procedural）。Ethainter [14] 则是一个颇具竞争力的选项，能较好地应对 C1 和 C2，但它在处理 EVM 线性内存模型的复杂性时存在不足，尤其难以处理 EVM 中动态分配和释放的内存场景；一旦合约执行复杂的内存操作，或在内存中存储并操作中间数据（如 §2.2 提到的三种验证机制），它的污点追踪准确性可能会受到影响。

**我们的核心思路 (Our Key Idea)**

如上所述，符号执行与污点分析在恢复语义、进行控制流与数据流的跨过程分析方面具备一定有效性。然而，符号执行在确保分析完备性的同时往往遭遇效率问题。基于此，我们选择使用基于静态 EVM 模拟的污点分析来跟踪字节码中污点的传播。为降低静态模拟可能带来的误报，并过滤掉会触发利用场景的可行路径，我们设计了与 §3.1 所述三条原则（P1、P2、P3）相对应的“三阶段”检测器。此外，为了克服 Ethainter 在处理 EVM 稀疏线性内存上遇到的困难，我们借鉴了 He 等人 [39] 的思路，将线性内存抽象为键值对（key-value pairs）。因此，我们的设计能够同时解决 C1 和 C2。进一步地，AVVERIFIER 通过自研的 EVM 模拟器来模拟栈和内存，从而捕捉地址相关数据的传播情况，并在非动态数据的场景下保持高效性。至于动态内存参数，AVVERIFIER 采取保守方式将它们视作符号处理，只保证栈的平衡性，避免了因枚举所有可能值而导致的额外开销。

## Design of AVVERIFIER

本节将详细说明 AVVERIFIER 的技术细节，阐述它在检测以太坊智能合约中地址验证漏洞时所采用的方法。我们首先在 §4.1 对整体思路进行概述，并在 §4.2 介绍所使用的符号。随后，在 §4.3 至 §4.5 中分别讨论其三个核心组件。

### 概述

<p style="text-align:center"><img src="./1.png" alt="bug"/></p>

如图 1 所示，AVVERIFIER 的整体架构与工作流程可分为三个主要组件：代码图构建器（code grapher，文中简称 Grapher）、EVM 模拟器（EVM simulator，简称 Simulator）以及漏洞检测器（vulnerability detector，简称 Detector）。具体而言，AVVERIFIER 仅接收 Solidity 智能合约的字节码作为输入。

- **Grapher**：首先会将字节码解析为控制流图（CFG），从中筛选出所有可疑函数作为候选，并将这些候选交给 Simulator。
- **Simulator**：维护一个由两部分组成的状态信息（state）。第一部分是 EVM 所需的数据结构，包括栈（stack）、内存（memory）与存储区（storage）（参考 §2.1）；第二部分则是收集到的污点信息。Simulator 会根据控制流图及操作码序列不断更新状态中的相应字段。它还使用基于启发式的路径选择方法，重点关注最有可能导致漏洞的路径。一条路径分析完成后，对应的状态会发送给 Detector。
- **Detector**：在得到 Simulator 所提供的状态后，判断合约是否存在地址验证漏洞。它采用三级串联（cascaded three-phase）的检测策略，结合漏洞的内在特征（P1 至 P3）来排除误报和漏报。

### 符号定义

为更好地解释 `AVVerifier` 的实现，我们在此定义一些符号：


$S$: 用户可控的源 (\emph{sources}) 集合；

$T$: 被污染 (\emph{tainted}) 的变量集合；

$C_T$: 从被污染变量到其来源 (\emph{sources}) 的映射；

$F$: 可疑函数 (\emph{suspicious functions}) 的集合；

$\mathrm{Mem}$, $\mathrm{Sto}$: 分别表示 EVM 中的内存区 (\emph{memory}) 与存储区 (\emph{storage})；

$V$, $EC$, $SM$: 检测器 (\emph{Detector}) 中三阶段检测的标识。它们各自以函数 $f$ 和参数 $p$ 作为输入。
