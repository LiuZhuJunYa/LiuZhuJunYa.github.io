---
title: SoK：理解 zk-SNARKs：研究与实践之间的差距
date: 2025-10-05
categories: 
  - 论文阅读
---

## 作者

<p style="text-align:center">Junkai Liang¹,，Daqi Hu¹,，Pengfei Wu²,*，Yunbo Yang³，Qingni Shen¹,†，Zhonghai Wu¹,†</p>
<p style="text-align:center">¹ 北京大学，² 新加坡管理大学，³ 华东师范大学</p>

## 摘要

零知识、简洁、非交互式的知识论证（zk-SNARK）作为一种强有力的技术，用于证明计算的正确性，并已引起研究人员的高度关注。学术界和工业界提出了大量具体方案与实现。不幸的是，zk-SNARK 的内在复杂性在研究人员、开发者与用户之间造成了差距，因为他们对这项技术的关注点并不相同。例如，研究人员致力于构建新的高效证明系统，使其具有更强的安全性和新的性质。与此同时，开发者与用户更关心实现所依赖的工具链、可用性与兼容性。这一差距阻碍了 zk-SNARK 领域的发展。

在这项工作中，我们对 zk-SNARK 从理论到实践进行了全面研究，明确指出其中的差距与局限。我们首先提出一个“总配方”，以统一将程序转换为 zk-SNARK 的主要步骤。随后，我们按照关键技术对现有的 zk-SNARK 进行分类。我们的分类刻画了现有 zk-SNARK 方案在具有实际价值的性质上的主要差异。我们调研了自 2013 年以来超过 40 种 zk-SNARK，并提供了一张参考表，列出其类别与性质。按照该“总配方”的步骤，我们进一步调研了 11 个通用且广泛使用的库，并详细阐述了这些库的可用性、兼容性、效率及其局限性。鉴于安装与运行这些 zk-SNARK 系统具有挑战，我们还提供了一个完全虚拟的环境，可在其中为每个系统运行其编译器。我们发现，在密码学学术界，证明系统是主要关注点；相对地，在工业界，约束系统形成了瓶颈。为弥合这一差距，我们提出了若干建议，并呼吁开源社区加强文档、标准化与兼容性建设。

## 1 引言

*设想你有一位红绿色盲的朋友，她怀疑红色和绿色其实并不是不同的颜色。你想向你的朋友证明这两种颜色确实不同。我们的问题是：在不泄露你所使用物体的真实颜色的前提下，你要如何做到这一点？*

上述“色盲验证者”[1] 是一个在用日常情境思考零知识证明（ZKP）时的经典问题。其解法也很容易理解：你为你的朋友准备一个红球和一个绿球，并让她选一个作为她的最爱。随后她把两只球都遮住，随机选出一个，问你它是不是她最喜欢的那个。如果红色和绿色确实不同，你可以以概率 1 成功；否则，你只能以概率 1/2 成功[3]。你的朋友可以重复这个过程，以使她相信“纯属巧合”的概率可以忽略不计。

对上述思想实验进行自然的形式化，会得到 ZKP 的一种交互式形式，在这种形式中，验证者与证明者之间有一轮或多轮交互[2]，也就是所谓的交互式证明（IP）。IP 是 ZKP 领域的一项突破，因为它被用来证明对所有属于非确定性多项式时间（NP）类问题的解的“知识”，从而把 ZKP 的能力从日常情境扩展到了计算模型[3]。IP 功能强大，但可能需要多轮交互，这会增加通信负担，并且对某些应用（例如区块链或保密机器学习）来说并不现实。非交互式零知识（NIZK）证明关注的是这样一类协议：证明者只向验证者发送一条消息（即证明），验证者据此决定是否接受。NIZK 的主要目的在于解决交互性带来的时延问题。幸运的是，可以通过通用的变换把 IP 与 NIZK 桥接起来，例如 Fiat–Shamir 变换[4]，它允许证明者生成哈希值，仿佛这些哈希值是由验证者给出的随机消息。沿着这些理论进展，已经有人提出了用于“三可着色问题”和“3-可满足性问题”的 IP 与 NIZK 协议[3,5]。然而，这些工作在渐近开销上很大，因而并不实用。为更好地应对真实世界场景，NIZK 还被进一步要求具备“简洁性”，也就是说证明者与验证者所用的时间与内存都是有界的。具备简洁性的 NIZK（亦即 zk-SNARK）已成为面向实际应用的 ZKP 研究主流。ZKP、NIZK 与 zk-SNARK 之间的关系见图 1。

<p style="text-align:center"><img src="./1.jpg" alt="bug"/></p>

<p style="text-align:center">图 1：ZKP、NIZK 与 zk-SNARK 的包含关系。</p>

源自 ZKP 和 NIZK，zk-SNARK 提供了一种机制，使不互信的一方能够证明自己对 NP 关系的知识，而生成的证明不泄露任何关于私有见证的信息。这一宝贵性质使 zk-SNARK 成为强大的密码学基元，使得在不暴露私有输入的情况下验证计算正确性成为可能。过去几年间，围绕 zk-SNARK 应用涌现出一波突破性的科学成果，范围包括但不限于金融服务（如区块链支付 [6,7,8]）、智能合约 [9,10]，以及机器学习 [11,12]、多方计算 [13,14,15] 和后量子密码学 [16,17] 等学术领域。zk-SNARK 还拥有可观的市场前景。迄今为止，基于 zk-SNARK 的、被广泛使用的区块链已有 10 余条，并有估计认为，到 2030 年仅用于生成 ZK 证明的交易费用就将达到 100 亿 [18]。除区块链服务外，Axiom [19]、FedML [20] 与 Giza [21] 等众多公司也在合作构建面向隐私保护型机器学习及其他应用的 ZK 生态系统。

尽管 zk-SNARK 具有很强的通用性、简洁性，并像加密与签名算法那样具备广泛应用的潜力，但研究与实践之间仍存在差距，阻碍了 zk-SNARK 的发展。研究者与从业者在 zk-SNARK 的三个概念上关注点不同：约束系统、证明系统与编译器。约束系统表示我们希望被证明的问题，例如某些具体的 NP 关系（如 3-可满足性）。证明系统表示生成该关系证明的具体密码学技术。编译器是将我们想要证明的高级程序转换为数学形式的约束系统的实用工具。

研究人员主要致力于为不同的约束系统设计不同的证明系统，以达到特定性质。迄今为止，已有一些方案具备非常实用的性质，例如常数大小的证明、线性复杂度的证明者、后量子安全性以及透明设置。然而，这些性质并未集成到同一个方案中，彼此之间存在取舍。要理解这些取舍，需要具备大量 zk-SNARK 的数学背景知识；从实务角度看，这相当艰难，致使从业者难以为其应用选择合适的方案。此外，对从业者而言，最耗时且最容易出错的环节在于使用编译器。正如文献 [22,23,24,25] 所报道的那样，程序员在正确实现自身的 zk-SNARK 应用方面屡屡受挫，并且由于误解编译器语言而产生了数以百计的漏洞。

我们在 zk-SNARK 领域识别出学术界与工业界视角之间的若干鸿沟：（1）用户在选择方案时需要专家级知识；（2）编译器的重要性被低估。为此，我们关注以下研究问题：

> **RQ1：** 如何给出一份统一的“总配方”，以梳理不同 zk-SNARK 背后的设计原则与优化？
> **RQ2：** 能否针对不同的真实场景提供选择 zk-SNARK 的指导？
> **RQ3：** 基于总配方与实验，并细致审视既有工作，我们能否为学术研究者与库的设计者提供新的洞见？

**我们的工作：** 为回答这些问题，我们对 zk-SNARK 及其库进行了系统性综述。首先，我们提出一份统一的总配方，用以勾勒主流 zk-SNARK 的设计原则。该配方包含关键步骤：将高级程序编译为电路，将电路交由证明系统以生成一个 IP（交互式证明），并应用通用变换以产生最终的 zk-SNARK。除此之外，我们还探讨 zk-SNARK 的主要应用，如保密区块链、零知识机器学习以及密码学用途。

依照总配方，我们对证明系统进行分类，并在各类别中追踪其演化。这有助于非专家用户选择合适的 zk-SNARK 方案。随后，我们基于性能与可用性评估了全部 11 个最先进的 zk-SNARK 库。通过性能分析，我们针对不同需求给出实现 zk-SNARK 的最佳实践建议。此外，我们识别出当前库中的常见问题，并呼吁改进文档与标准化。

我们强调，本论文及其开源材料面向四类读者：（1）希望通过理解最先进的库，从理论走向实践的研究人员；（2）希望将某个组件实现为 zk-SNARK 工具包的开发者；（3）希望实现自有 zk-SNARK 应用的程序员；以及（4）希望了解某个 zk-SNARK 应用是否满足自身需求的用户。我们认为这些工作是必要的，并能够促进实践者更好地利用 zk-SNARK 的成果。

**贡献概述：** 虽然我们并非首次综述该主题，但我们将本工作定位为首个对过去十年研究与实践进行系统化梳理的工作，着眼于借助最先进的库来应对新出现的挑战。概括而言，我们有五点主要贡献：

* 我们给出了一份统一的总配方，展示了一个高级程序如何从起点到终点被转换为 zk-SNARK。在该总配方之内，我们在第 3 节建立了一个全面综述，涵盖实际 zk-SNARK 中使用的不同电路、约束系统、技术与应用。
* 在总配方的指导下，我们进一步调研了 40 余种 zk-SNARK，并提供了证明系统的全面对比表；我们讨论了总配方与本次调查如何有助于弥合这些差距。
* 我们调研了全部 11 个 zk-SNARK 库，并基于性能与可用性进行比较；我们提出最佳实践的实现方案，并分析各库的架构、工具集与文档。
* 我们在 Docker 容器中提供了精心设计的测试代码示例；我们相信这将有助于 zk-SNARK 开源社区的发展，并帮助用户利用 zk-SNARK 领域的成果。我们所有代码与文档已发布在永久仓库，获取地址为：https://doi.org/10.5281/zenodo.14682405。
* 基于全面分析，我们从三个视角给出关键洞见与建议：面向非专家的库选择与编程指南、研究者的未来方向，以及对库设计者的建议。

**相关工作：** 以往关于 ZKP 的综述大体分为两类。**其一**，关于 zk-SNARK 的构造与理论应用的综述。例如，Feng 和 Mcllin【26】介绍了 zk-SNARK 的基础及其在 NP 计算中的用法；Nituslescu【27】聚焦于基于二次算术程序（QAP）的 zk-SNARK；Li 等【28】按技术对 zk-SNARK 进行分类，但更关注诸如约束系统和分层电路等小众实现。也有其他工作【29，30】讨论范围证明并提供实践性建议。然而，这些工作只覆盖了 zk-SNARK 的一小部分，而且主要偏学术性。与之相对，我们的工作贯通理论与实践，提供更广泛的洞见。**其二**，关于实际 zk-SNARK 实现中漏洞的综述。既有研究强调了电路层【23，31，32】、编译阶段【24】以及面向具体应用的完整性层【33，34】存在的问题；Chaliasos 等【25】对这些漏洞作了全面总结。我们的工作不同之处在于，为 zk-SNARK 实践者提供一份全面的操作指引，并着重可用性、效率、兼容性与库的选择，旨在在强调软件安全的同时，减少对密码学不熟悉的实践者出现错误。

<p style="text-align:center">表 1：缩写及对应全称</p>

| 缩写     | 全称                                                         |
| -------- | ------------------------------------------------------------ |
| AIR      | 算术中间表示（Arithmetic Intermediate Representation）       |
| CRS      | 公共参考字符串（Common Reference String）                    |
| DEIP     | 双重高效交互式证明（Doubly Efficient Interactive Proofs）    |
| (e)DSL   | （嵌入式）领域特定语言（(embedded) Domain-Specific Language） |
| FFT      | 快速傅里叶变换（Fast Fourier Transform）                     |
| FRI      | 快速 Reed–Solomon 邻近性 IOP（Fast Reed–Solomon IOP of Proximity） |
| HDL      | 硬件描述语言（Hardware Description Language）                |
| I(O)P    | 交互式（预言机）证明（Interactive (Oracle) Proof）           |
| IPA      | 内积论证（Inner Product Argument）                           |
| ITP      | 信息论证明（Information-Theoretic Proof）                    |
| MPC      | 多方计算（Multi-Party Computation）                          |
| NIZK     | 非交互式零知识（Non-Interactive Zero-Knowledge）             |
| NP       | 非确定性多项式时间（Non-deterministic Polynomial Time）      |
| PL       | 编程语言（Programming Language）                             |
| (L)PCP   | （线性）概率可检验证明（(Linear) Probabilistically Checkable Proof） |
| PCS      | 多项式承诺方案（Polynomial Commitment Scheme）               |
| PIOP     | 多项式交互式预言机证明（Polynomial Interactive Oracle Proof） |
| QAP      | 二次算术程序（Quadratic Arithmetic Program）                 |
| QSP      | 二次跨度（张成）程序（Quadratic Span Program）               |
| R1CS     | 秩-1 约束系统（Rank-1 Constraint System）                    |
| STARK    | 可扩展透明的知识论证（Scalable Transparent ARguments of Knowledge） |
| ZKP      | 零知识证明（Zero-Knowledge Proof）                           |
| ZKML     | 零知识机器学习（Zero-Knowledge Machine Learning）            |
| zk-SNARK | 零知识、简洁、非交互式知识论证（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge） |
| zk-VM    | 零知识虚拟机（Zero-Knowledge Virtual Machine）               |

## 2 背景

在本节中，我们聚焦于 zk-SNARK 的概念，并在第 2.1 节介绍其定义，同时在第 2.2 节介绍主流技术。此外，我们在表 1 中汇总了所有缩写及其全称。借助这些符号，我们讨论 zk-SNARK 的研究发展。

### 2.1 IP、NIZK 与 zk-SNARK 的概念

这里我们介绍 ZKP 领域中广泛使用的 IP【35】、NIZK【36】与 zk-SNARK【37】的形式化概念。它们的相似之处在于：对于一个固定的 NP 关系 $R$，证明者可以使验证者信服，即对公开输入 $x$，他们知道一个见证 $w$，使得 $(x, w) \in R$。不同之处在于，IP 允许多轮通信，而 NIZK 与 zk-SNARK 是非交互式的。此外，zk-SNARK 还进一步具有效率方面的要求。

**定义 2.1（IP）。** 设 $R$ 是由某个 NP 语言 $L$ 所诱导的二元关系。给定公共输入 $x$ 与证明者的输入 $w$，我们把证明者 $P$ 与验证者 $V$ 之间的交互记作 $\langle P(w),V\rangle(x)$。若存在一个可忽略函数 $\varepsilon$ 使得下述性质成立，则称二元组 $(P, V)$ 是 $L$ 的一个 IP 系统：

- **完备性（Completeness）：** 若 $(x,w)\in R$，则 $\Pr[\langle P(w),V\rangle(x)=1]=1$。
- **可靠性（Soundness）：** 若 $(x,w)\notin R$，并且对于任意恶意证明者 $P^{\ast}$，都有 $\Pr[\langle P^{\ast}(w),V\rangle(x)=1]\le \varepsilon(|x|)$。

**定义 2.2（NIZK）。** 一个 NIZK 证明由三个算法组成（$\mathrm{Setup},\ \mathrm{Prove},\ \mathrm{Verify}$），定义如下：

- $\mathrm{Setup}(pp)\to (pk,vk)$：在输入公共参数 $pp$ 时，输出证明密钥与验证密钥 $pk,vk$。
- $\mathrm{Prove}(pk,x,w,R)\to \pi$：在输入 $pk$、实例与见证对 $(x,w)$，以及关系 $R$ 时，输出证明 $\pi$。
- $\mathrm{Verify}(vk,x,\pi)\to {0,1}$：在输入 $vk,x,\pi$ 时，输出 $1$ 或 $0$，分别表示是否接受 $\pi$。

此外，NIZK 证明需要满足以下三个性质：

- **完备性（Completeness）：** 给定 $(x,w)\in R$，诚实的证明者将使验证者输出 $1$。
- **可靠性（Soundness）：** 给定 $(x,w)\notin R$，与验证者交互的恶意证明者只能以可忽略的概率使其输出 $1$。
- **零知识（Zero knowledge）：** 给定 $(x,w)\in R$，存在一个模拟器，能在与一个（可能是恶意的）验证者交互的情形下，产生与诚实证明者“视图”等价的输出；该视图在计算上与真实执行（证明者与验证者之间的实际交互记录）不可区分。注意：模拟器拿不到 $w$，而证明者拿到 $w$；因此从验证者视角看，证明并不包含关于 $w$ 的信息。

当**证明大小**与**验证时间**都被待证陈述规模所界定时，NIZK 被称为 **zk-SNARK**：

- 证明大小相对于电路规模是**多对数级**（polylogarithmic）的；
- 验证时间相对于电路规模也是**多对数级**的。

此外，还存在其他概念，如**可扩展透明的知识论证**（STARK）【38】与**双重高效交互式证明**（DEIP）【39】——它们给出了与 zk-SNARK 类似的 ZKP 体系。实际上，这些概念可视作 zk-SNARK 的变体，主要区别在于引入了新的性质。例如，STARK 要求**透明设置**、**标准模型**下的构造以及**后量子安全性**；DEIP 要求证明端具有**近线性**的复杂度。为简明起见，本文用 **zk-SNARK** 统称高效的 NIZK 证明。

### 2.2 密码学技术

在本节中，我们介绍**交互式预言机证明**（interactive oracle proof, **IOP**），它是 **IP** 的一种推广。我们也介绍**多项式承诺方案**（polynomial commitment scheme, **PCS**），它可以在 **IOP** 中实例化预言机。我们之所以重视 **IOP** 与 **PCS**，是因为它们有助于搭建主流证明系统的结构。更多信息（包括具体构造）参见文献【40】。

**定义 2.3（IOP）。** 设公共输入为 $x$（验证者与证明者皆知），见证串为 $w$（仅证明者所知），并令**轮复杂度** $r(x)\in\mathbb{N}$。一个具有 $r(x)$ 轮的 IOP 系统规定：在每一轮中，证明者向验证者发送一条消息（该消息可依赖见证 $w$ 以及先前消息），验证者具有**预言机访问**（oracle access），随后验证者向证明者返回一条消息。与证明者交互结束后，验证者的输出要么是 $\mathsf{accept}$，要么是 $\mathsf{reject}$。

更具体地，设 $R$ 是由某个 NP 语言 $L$ 所诱导的二元关系，且**可靠性误差**为 $\varepsilon\in[0,1]$。若一对交互式随机算法 $(P,V)$ 满足下列性质，则称其是 $L$ 的、误差为 $\varepsilon$ 的 IOP 系统：

- **完备性（Completeness）：** 若 $(x,w)\in R$，则
   $$\Pr\big[V(\langle P(x,w)\rangle,x)=\mathsf{accept}\big]=1.$$
- **可靠性（Soundness）：** 若 $(x,w)\notin R$，则对任意证明 $\pi$，都有
   $$\Pr\big[V(\pi,x)=\mathsf{accept}\big]\le \varepsilon.$$

作为 IOP 的一个特例，**多项式 IOP（PIOP）** 表示一种类似的交互过程：证明会生成能够对次数低于给定上界的多项式进行求值的预言机。为保证隐私，PIOP 通常通过 **PCS** 来实例化，定义如下。

**定义 2.4（PCS）。** PCS 允许证明者先对一个多项式 $f$ 进行承诺，随后在指定点上证明该被承诺多项式的求值是正确的。PCS 由四个算法组成：$\mathrm{Setup}$、$\mathrm{Commit}$、$\mathrm{Open}$ 与 $\mathrm{VerifyPoly}$。

- $\mathrm{Setup}(1^{\kappa})\to \mathrm{ck}$：输入安全参数 $\kappa$，输出承诺密钥 $\mathrm{ck}$。
- $\mathrm{Commit}(\mathrm{ck},f)\to \mathrm{com}$：输入 $\mathrm{ck}$ 与多项式 $f$，输出对 $f$ 的承诺 $\mathrm{com}$。
- $\mathrm{Open}(\mathrm{ck},f,\mathrm{com},i)\to \big(f(i),\pi\big)$：输入 $\mathrm{ck},f,\mathrm{com}$ 及给定点 $i$，输出取值 $f(i)$ 与证明 $\pi$。
- $\mathrm{VerifyPoly}(\mathrm{ck},\mathrm{com},i,f(i),\pi)\to\{0,1\}$：输入 $\mathrm{ck},\mathrm{com},i,f(i),\pi$，若接受则输出 $1$，否则输出 $0$。

我们强调：以 **PCS** 实例化的 **PIOP** 是当前构建 **zk-SNARK** 的主流技术。通过不同的 PCS 实例化，可以实现 zk-SNARK 所需的性质（例如短证明、透明性以及后量子安全性）。此外，还有其他技术，如**二次算术程序**（QAP），可用于把**常数大小的概率可检验证明**（PCP）构造成 zk-SNARK【37】。下文我们将对这些技术作简要介绍。

**定义 2.5（PCP）。** 设 $R$ 为由某个 NP 语言 $L$ 所诱导的二元关系，且令 $,\varepsilon\in(0,1),$ 为一个概率。若存在用于验证者的**随机化多项式时间**算法 $V$ 满足下述性质，则称 $R\in \mathrm{PCP}(r,q)$：

- **效率（Efficiency）：** 在由见证 $w$ 生成证明 $\pi$ 之后，$V$ 在验证时至多使用 $r$ 个随机硬币，并且至多读取 $\pi$ 的 $q$ 位。
- **完备性（Completeness）：** 若 $(x,w)\in R$，则 $\Pr\big[V(x,\pi)=1\big]=1$。
- **可靠性（Soundness）：** 若 $x\notin L$，则对所有 $\pi$，都有 $\Pr\big[V(x,\pi)=1\big]<\varepsilon$。

IP、PCP 与 IOP 统称为**信息论证明**（Information-Theoretic Proof，ITP），它作为最终 zk-SNARK 方案的抽象。它们之间有两点不同：其一，IP 与 IOP 允许在**不显式生成**证明 $\pi$ 的情况下进行交互，而 PCP 是**非交互式**的；其二，PCP 与 IOP 使用验证者可以自由访问的**预言机**。这些预言机作为黑箱为验证者提供额外的计算能力，并简化协议设计。为便于理解这些概念，我们在**附录 A** 中给出一个数独示例。

> A  ITP 的数独示例
>
> **情景：** 当需要说服他人某个数独题只有一个解时，我们可以分别使用 IP、PCP 或 IOP，并比较它们的差异。
>
> **IP：** 验证者可以向拥有完整解的证明者随意提问，例如：
>  • “第 3 行第 5 列的数字是什么？”
>  • “为什么数字 8 不能出现在第 7 个宫里？”
>  • “解释一下你是如何推得第 2 行第 1 列的数字的？”
>
> **PCP：** 证明者把完整解写在一张很大的纸上（即 PCP 证明）。验证者被允许**随机**选择若干格进行检查（对该证明进行随机的“预言机式”访问）：
>  • “检查第 2 行第 8 列的数字。”
>  • “检查第 6 行第 3 列的数字。”
>  • “检查第 9 行第 9 列的数字。”
>
> **IOP：** 证明者同样提供类似 PCP 的预言机，但验证者拥有更多的交互方式。
>  • 首先，证明者在若干张纸上写下一些提示（预言机），例如“每一行与每一列的数字之和为 45”、“每个宫包含 $1$ 到 $9$ 的数字”，或某个具体的推理步骤。
>  • 然后，验证者可以就这些提示发问，例如“给我看一下第 3 行数字的排列”，或“给我看一下第 5 个宫里的数字”。
>  • 最后，验证者可以随机抽查所提供提示的部分内容。

